{"version":3,"file":"main.js","mappings":"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","sources":["webpack://Trans/webpack/universalModuleDefinition","webpack://Trans/webpack/bootstrap","webpack://Trans/webpack/runtime/define property getters","webpack://Trans/webpack/runtime/hasOwnProperty shorthand","webpack://Trans/webpack/runtime/make namespace object","webpack://Trans/./core/types.ts","webpack://Trans/./core/errors.ts","webpack://Trans/./core/Trans/helpers.ts","webpack://Trans/./core/ContentPreparer/helpers.ts","webpack://Trans/./core/ContentPreparer/ContentPreparer.ts","webpack://Trans/./core/Trans/Trans.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Trans\"] = factory();\n\telse\n\t\troot[\"Trans\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { TransError } from './errors';\n\nexport type Content = Record<string, unknown>;\nexport type DynamicContent<T extends Content> = () => Promise<{ default: T }>;\nexport type Variables = Record<string, string>;\nexport type ErrorsMode = 'ignore' | 'throw' | ((error: TransError) => string);\nexport type PluralContent = Partial<Record<Intl.LDMLPluralRule, string>>;\nexport type PluralFn = (count: number, locale: string) => Intl.LDMLPluralRule;\nexport enum Config {\n  count = 'COUNT',\n}\n\nexport type TranslateOptions<T extends Variables = Variables> = {\n  /**\n   * ignore the error, handle error or throw error (by default)\n   * */\n  errorsMode?: ErrorsMode;\n  /**\n   * it uses for the plural if it exists\n   * */\n  count?: number;\n  /**\n   * for replaced the variable patters - ${variable}\n   * */\n  variables?: T;\n};\n\nexport type Translate<T extends Variables = Variables> = (\n  path: string | TemplateStringsArray,\n  options?: TranslateOptions<T>\n) => string;\n\nexport declare class Trans<Locale extends string = string> {\n  locale: Locale;\n\n  content: Content;\n\n  init<T extends Content>(params: {\n    translations: Record<Locale, T>;\n    locale: Locale;\n    pluralRecord?: Record<Locale, PluralFn>;\n  }): Promise<void>;\n\n  init<T extends Content>(params: {\n    translations: Record<Locale, DynamicContent<T>>;\n    locale: Locale;\n    pluralRecord?: Record<Locale, PluralFn>;\n  }): Promise<void>;\n\n  changeLocale(locale: Locale): Promise<void>;\n\n  createTranslate<T extends Variables = Variables>(module: string | TemplateStringsArray): Translate<T>;\n}\n","/* eslint-disable max-classes-per-file */\n\nexport class ContentNotFound extends Error {}\nexport class ContentNotPlural extends Error {}\nexport class PluralNotSupport extends Error {}\nexport class InvalidTranslate extends Error {}\nexport class InvalidPath extends Error {}\nexport class InvalidErrorMode extends Error {}\n\nexport type TransError = InvalidTranslate | ContentNotFound | ContentNotPlural;\n","import { Content, ErrorsMode } from '../types';\nimport { InvalidErrorMode, InvalidPath } from '../errors';\n\nexport type PathArray = string[];\n\nexport const preparePath = (path: string): PathArray => path.split('.');\n\nexport const parsePath = (path: string | TemplateStringsArray): string => {\n  if (Array.isArray(path)) return path[0];\n  if (typeof path === 'string') return path;\n  throw new InvalidPath(`invalid path: ${path}, path as json: ${JSON.stringify(path)}`);\n};\n\nexport const getContentRecursive = (content: Content, pathArray: PathArray): Content | string => {\n  if (!content) return content;\n  const path = pathArray.shift();\n  if (pathArray.length) {\n    return getContentRecursive((content as Record<string, Content>)[path], pathArray);\n  }\n  if (path) {\n    return content[path] as Content | string;\n  }\n  return content;\n};\n\nexport const getContent = (content: Content | string, path: string): Content | string => {\n  if (!content || typeof content !== 'object') return content;\n  const pathArray = preparePath(path);\n  return getContentRecursive(content, pathArray);\n};\n\nexport const validate = (callback: () => string, errorsMode: ErrorsMode = 'throw', extra = ''): string | never => {\n  try {\n    return callback();\n  } catch (e) {\n    if (errorsMode === 'ignore') return '';\n    const error = new Error([`${e.message}`, extra].filter(Boolean).join('. '));\n    if (errorsMode === 'throw') throw error;\n    if (typeof errorsMode === 'function') return errorsMode(error);\n    throw new InvalidErrorMode(`errorsMode: \"${errorsMode}\"; as a json: ${JSON.stringify(errorsMode)}`);\n  }\n};\n","import { PluralContent } from '../types';\nimport { ContentNotPlural, InvalidTranslate, PluralNotSupport } from '../errors';\nimport { ContentPreparerOptions } from './ContentPreparer';\n\nexport const defaultPluralFn = (count: number, locale: string): Intl.LDMLPluralRule => {\n  try {\n    return new Intl.PluralRules(locale).select(count);\n  } catch (e) {\n    if (e.message === 'Intl is not defined') {\n      throw new PluralNotSupport(\n        `plural by default is not supported. Try to add a polyfill for Intl: https://formatjs.io/docs/polyfills/intl-pluralrules/ or you should to pass a pluralRecord with own functions for plural`\n      );\n    }\n    throw e;\n  }\n};\n\nexport const setCount = <Locale extends string>({\n  count,\n  content,\n  pluralFn,\n  locale,\n}: {\n  count: number;\n  locale: Locale;\n  content: PluralContent;\n  pluralFn: ContentPreparerOptions<Locale>['pluralFn'];\n}): string | never => {\n  if (!content || typeof content !== 'object') {\n    throw new ContentNotPlural(`content is not plural. content: \"${content}\"; as a json: ${JSON.stringify(content)}`);\n  }\n  const key = pluralFn(count, locale);\n  const result = content[key];\n  if (typeof result !== 'string')\n    throw new InvalidTranslate(`invalid translate. Translated result: ${result}; as a json: ${JSON.stringify(result)}`);\n  return result;\n};\n\nexport const setVariable = (content: string, variable: { key: string; value: string }): string => {\n  const regExp = new RegExp(`\\\\\\${${variable.key}}`, 'g');\n  return content.replace(regExp, variable.value);\n};\n","import { Config, Content, PluralContent, PluralFn, Variables } from '../types';\nimport { InvalidTranslate } from '../errors';\nimport { defaultPluralFn, setCount, setVariable } from './helpers';\nimport { getContent, parsePath } from '../Trans/helpers';\n\nexport type ContentPreparerOptions<Locale extends string> = {\n  pluralFn?: PluralFn;\n  locale: Locale;\n  path?: string | TemplateStringsArray;\n};\n\nexport class ContentPreparer<Locale extends string> {\n  private locale: Locale;\n\n  private _content: Content | string;\n\n  private pluralFn: ContentPreparerOptions<Locale>['pluralFn'];\n\n  set(content: Content | string, options: ContentPreparerOptions<Locale>): this {\n    const { pluralFn = defaultPluralFn, locale, path = '' } = options;\n    const parsedPath = parsePath(path);\n    this._content = getContent(content, parsedPath);\n    this.locale = locale;\n    this.pluralFn = pluralFn;\n    return this;\n  }\n\n  setVariables(variables: Variables): this {\n    if (!variables || typeof variables !== 'object') return this;\n    if (typeof this._content !== 'string') {\n      throw new InvalidTranslate(`invalid content: \"${this._content}\"; as a json: ${JSON.stringify(this._content)}`);\n    }\n    let result = this._content;\n    const keys = Object.keys(variables);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      result = setVariable(result, { key, value: variables[key] });\n    }\n    this._content = result;\n    return this;\n  }\n\n  setCount(count: number): this {\n    if (!count && count !== 0) return this;\n    this._content = setVariable(\n      setCount({\n        count,\n        content: this._content as PluralContent,\n        pluralFn: this.pluralFn,\n        locale: this.locale,\n      }),\n      { key: Config.count, value: count.toString() }\n    );\n    return this;\n  }\n\n  get content(): string | Content {\n    return this._content;\n  }\n}\n","import { Content, DynamicContent, PluralFn, Translate, TranslateOptions, Variables, Trans as ITrans } from '../types';\nimport { getContent, parsePath, validate } from './helpers';\nimport { InvalidTranslate } from '../errors';\nimport { ContentPreparer } from '../ContentPreparer';\n\nexport class Trans<Locale extends string = string> implements ITrans<Locale> {\n  locale: Locale;\n\n  private translations: Record<Locale, Content>;\n\n  private pluralRecord: Record<Locale, PluralFn>;\n\n  private contentPreparer: ContentPreparer<Locale>;\n\n  content: Content;\n\n  private async _setContent<T extends Content>(content: T | (() => Promise<{ default: T }>)): Promise<void> {\n    if (typeof content === 'function') {\n      this.content = (await content()).default;\n      return;\n    }\n    this.content = content;\n  }\n\n  async init<T extends Content | Record<string, DynamicContent<T>>>(params: {\n    translations: Record<Locale, T>;\n    locale: Locale;\n    pluralRecord?: Record<Locale, PluralFn>;\n  }): Promise<void> {\n    const { translations, locale, pluralRecord } = params;\n    const { [locale]: content } = translations;\n    this.translations = translations;\n    this.pluralRecord = pluralRecord;\n    this.locale = locale;\n    this.contentPreparer = new ContentPreparer<Locale>();\n    await this._setContent(content);\n  }\n\n  async changeLocale(locale: Locale): Promise<void> {\n    const { [locale]: content } = this.translations;\n    this.locale = locale;\n    await this._setContent(content);\n  }\n\n  createTranslate<T extends Variables = Variables>(module: string | TemplateStringsArray): Translate<T> {\n    const parsedPath = parsePath(module);\n    const content = getContent(this.content, parsedPath);\n\n    return (path: string | TemplateStringsArray, options: TranslateOptions<T> = {}): string => {\n      const { errorsMode, count, variables } = options;\n      return validate(\n        () => {\n          const { locale, pluralRecord } = this;\n\n          // find in the current content\n          const result = this.contentPreparer\n            .set(content, { path, locale, pluralFn: pluralRecord?.[locale] })\n            .setCount(count)\n            .setVariables(variables).content;\n          if (typeof result === 'string') return result;\n\n          // find in the root\n          const rootResult = this.contentPreparer\n            .set(this.content, { path, locale, pluralFn: pluralRecord?.[locale] })\n            .setCount(count)\n            .setVariables(variables).content;\n          if (typeof rootResult === 'string') return rootResult;\n\n          throw new InvalidTranslate(`invalid translate: \"${result}\"; as a json: ${JSON.stringify(result)}`);\n        },\n        errorsMode,\n        `full path: \"${[module, path].filter(Boolean).join('.')}\"; translate path: \"${path}\";`\n      );\n    };\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Config","Error","parsePath","path","Array","isArray","InvalidPath","JSON","stringify","getContentRecursive","content","pathArray","shift","length","getContent","split","preparePath","defaultPluralFn","count","locale","Intl","PluralRules","select","e","message","PluralNotSupport","setVariable","variable","regExp","RegExp","replace","set","options","pluralFn","parsedPath","this","_content","setVariables","variables","InvalidTranslate","result","keys","i","setCount","ContentNotPlural","toString","_setContent","default","init","params","translations","pluralRecord","contentPreparer","ContentPreparer","changeLocale","createTranslate","errorsMode","callback","extra","error","filter","Boolean","join","InvalidErrorMode","validate","rootResult"],"sourceRoot":""}